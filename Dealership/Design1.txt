MLH_Node: This class template defines what each node in the repository is. The only functions I have for it is an increment and a decrement, in order to make accesses to the number of elements each node is responsible for, a little bit cleaner to handle. The variables are the aforementioned elements, an array of keys, an array of data pointers, and an array of node pointers. 

MLH: This class template defines the whole repository, and essentially manipulates the previously defined nodes. This repository has a level, which keeps track of the current level, variables for keeping track of the objects, effort spent, and number of nodes, and also a printoption, that decides how things will be printed. There is also an array of pointers to nodes that will keep track of the path traversed when adding, deleting, or searching the MLH. 

I'll explain the simpler functions first. The incAll and decAll functions go through the path and call increment or decrement on each node. newNode creates a new node, and returns a pointer to it, very useful for cleaning things up. Printing is done recursively, the function takes in a node as a parameter, and first checks if it is a leaf, if so, the contents are printed, if not, the same print function is called on the next child pointer. In this way, every leaf node is printed. 

Insert takes in a key and an object. First, a pointer is created to traverse the repository. The first node is checked immediately, which would be the case the nothing has been added yet. If the first node is present, then the pointer is set to point to that. The first while loop will traverse the repository according to the hash function. That is, if the node keeps track of more than 5 elements, then the pointer is set to the child pointer of the hash result and the current level, after each traversal, the level is cremented. Okay, now we're at the node we want to add to. The next loop is a for loop, from 0 to the number of elements in the node. This simply searchs the node for a duplicate key. The next loop goes through the path, exploding each node that is full i.e. contains exactly 5 elements. Afterward, the pointer is set to the child pointer of the lowest node with a size less than 5. After everything is done, the element is inserted, then the rest of the parent nodes are incremented.

Delete is very similar to insert. First the first node is checked to see if it exists, if so, the pointer is set to it. During the traversal, if the child pointer that it's looking for doesn't exist, that means the object isn't there. Otherwise, it would reach the correct node, then it would search the contents of the node for a match. If found, the data is removed, and the last element is put in place of the removed one, and then it is removed from it's original spot, therefore leaving no gaps. If the node above ends up keeping track of 5 elements after the deletion, it is imploded. 

Explode will call hash on each key within the node and either create nodes to add it to, or add it to an already existing node. after that, it deletes everything from the parent(exploded) node. 
Implode checks each child and copies the key and data to the parent. It then deletes the child node.

Get simply traverses the repository according to the has function. If it ever comes across a null child, the key doesn't exist, if it comes across a node and searches it with no success, the key doesn't exist.
