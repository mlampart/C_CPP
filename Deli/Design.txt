Product: this class defines what a product is, which is an object with a name, price, total weight sold, and total revenue generated with each particular product. There are get functions for each parameter, and a set function for the price, in order to change the price of something if necessary. There is also a default function which resets the revenue and weight sold variables, when there is a new day. 

Price_List: this class defines the price list, you'll see later that the price list holds an array of products. To actually print the list, the function iterates thourhg the array printing the particular name and price of each element in the array. The constructor is where the array elements are actually defined, and this never changes unless the price happens to change. So to set the price, I take in the name as a parameter and check it against the elements in the array, and if it matches one, then that particular product element gets it's price changed. Otherwise, there is a get functions for the price, and also a get product function that works in the same way as setprice, this will be valuable later. This class also has a default function for a new day, which reassigns the default prices to each product just in case it was changed. 

Customer: I realized later on that a customer class wasn't really necessary because all it contains is an ID and a cart object. So I could have just given carts an ID, but I suppose this is a more realistic implementation, so it is what it is.

Cart: So first I needed to define a package, so this class contains a struct called bag which contains the name, weight, price (of the item per pound), total cost, and a next pointer, in order to make a list of these. So my cart can add a bag, destroy memory, print an invoice, and check out a customer. It's only variable is a pointer to the first bag in the cart. When adding a bag, it takes in the parameters of name, weight, and price, I first check if the weight is zero, meaning an empty package. If it is, then I print an error message and return. Otherwise, I create a new bag with the appropriate parameters (and also check if a memory allocation was successful). If the first bag doesn't exist yet, then the firstbag pointer points to the new bag, otherwise, I add the bag to the list kind of like a push onto a stack. To manage memory after a customer is checked out, I iterate through all the bags with two pointers side by side, deleting them. The invoice also iterates through the cart printing their parameters, all the while updating the total cost for everything. When the loop ends, the total cost is displayed. Checking out a customer is a little weird because it takes in the price list as a parameter. The cart is iterated through, while accessing the particular products's amtSold and revenue parameters and updating them. This is why I needed an accessor function for the product in price list.

Scale: The scale class contains a product, which represents what's currently on the scale. It contains a cutomer pointer, in order to access the cart which contains the products. It also has a weight parameter. Adding and subtracting weight simply updates the scale's weight with whatever the weight of the product was. I have it so that each addition or subtraction is a set fraction of one pound (to simulate getting slices of meat for example). Upon setting the product to be added, the user is presented with a menu. 'A' would call addweight, 'S' first checks if the scaleweight is about to be negative, then calls subweight. 'C' would add the whole 'bag' to the Cart as defined earlier. 

Deli: First I'll define the variables. Count and day work togother to keep track of what day it is, count will be explain a little later. Served keeps track of which customer is being served at the moment. numCust keeps track of the number of customers in order to check if it has reached maximum capactiy or not. numSold and revenue keep track of the total product sold and the total revenue; useful when report is called. The deli also contains an array of customer objects, 10 customer objects to be exact. It also has a scale, pricelist and a pointer to product. Before anything happens, the variables are set to zero, and each customer receives an ID number of 11. 11 isn't significant, it's just a number that no customer could possibly have since I chose that they receive anything between 1-10, so an ID of 11 represents an empty spot. There is a listprice function that does exactly that, to help with the user interface. To admit a customer, the function first checks if the maximum has been reached, if not, it iterates through the array of customers and when it reaches one who's ID is 11, it sets the ID as it's place in the array (assuming we start at 1 and end at 10). When a customer is chosen to be served, first, the variable served is updated, then the number is examined for validity; that is, the function checks whether the customer exists, or the number is outside of the range of possible ID's. If everything cheks out, then the scale is set to the customer being served. Now a menu shows up with various commands. The customer can choose a product to buy, look at the current invoice, check out, or cancel. Choosing a product will bring one to the menu defined in Cart. 'I' will call invoice and 'O' will call checkOut (explained later). 'C' will essentially deselect a customer, so if anything was put into the cart it would be...put back I guess, so the cartFix method would be called to manage memory. I have a listCustomers function which does exactly that, to make the interface more user-friendly. Checking out from the deli would manage the memory first, then set the customer ID to 11, meaning that customer now doesn't exist. Changing the price takes in the input of the name of the product, and the new price and goes directly into the pricelist and changes the value. And if the price is negative or the product name is wrong, an error will occur. Report simply displays each product, how much was sold, and the revenue of each. I ran into an issue; if I called report consecutively, the revenue would continue to update. So this is where 'count' comes in, I keep this number one behind 'day' and when I call report the first time, it'll increment 'count' and each time thereafter, report checks first if count equals day and if so, it still displays everything, but doesn't update any numbers. newDay fist checks out the remaining customers, then calls report as kind of a final report for the day. 'day' is incremented, and everything else is reset(pricelist, product prices, etc.)

Main: my main program first instantiates the deli, then enters a loop/menu. 'Q' stops the program, 'A' will add a new customer, 'S' will first list the customers then ask which one should be served, 'C' will prompt for a price change, 'O' will check out whoever is being served, 'R' will display a report, 'N' will start a new day.

