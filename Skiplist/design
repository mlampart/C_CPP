Starting from the top, I set my variables for my counter and my size variables. Size will keep track of the size of the lowest level, just to easily relay the information during the print. After defining my functions, I created a struct for each element, which included a parameter for the key, data pointer, next pointer, and down pointer. I decided to use a data pointer so that when an element is added to a higher level, the data can be easily accessed. I also created another struct for the stacks, the parameters being a pointer to an element, and a next pointer.

Repository_init:
	I first set whatever parameter was brought in as the new probability. I initialize the two stacks by setting the stack heads to NULL. Then I decided to initialize the superlist by creating two elements, one that will represent the top level, and another I call sentinel, that will always point to the top level. For each element, I still set the data to point somewhere else that contains the data just so I wouldn't need another struct. So from here on, I plan on using the head element data as a record of how many elements are in each repository.

newlevel:
	This is used when an element needs to be added to a higher level when one doesn't quite exist yet. I accomplish this by creating an element and pointing it to the current sentinel, and simply reinitializing the sentinel to point to the new element. 
Repository_insert:
	First, I need three pointers, will point to a new element to be added, p will traverse each level, and q will walk with p along the heads as it goes down levels (in order to increment the record of the data in the level). So p and q initally point to the head element of the top level. 
	The nested while loop logic simply checks whether the next element is either equal to the key, larger than the key, or NULL. If the key is equal, the function clears the stacks (by popping until the stack head is NULL) and returns. Otherwise, the current p and q elements are pushed onto the stack, saving the path. p and q are both pointed one element down, and they repeat, once p points to NULL, the loop breaks, and we have our paths!
	So first, both stacks must be popped in order to get back to where we were, the bottom level. An element is created, and placed right after the pointer p (and before what p was previously pointing to). After creating space for the data, I set the data pointer to point to that. The next part enters a while loop under the condition that there exists pointers in p's stack, i.e. if a path exists. If the coin flip is a success, then the next path pointer is popped off the stack, and the element is added, except in this case, the down pointer is set to the previous element. Afterward, the size record is incremented (by popping the next head off the stack). If the coin flip fails then the stack is cleared (to get rid of the rest of the path) and the function returns. If the path stack is empty but the coin flip is still a success, newlevel() is called, and the element is added, and since the pointer has to be at the head element, it's data is incremented.

Repository_delete:
	The traversal logic here is the same as that of the insert. However, if an element is found, a pointer to the previous element is pushed on the stack. If the element to be deleted isn't found i.e. the path stack is empty, then the function returns. Otherwise, we pop back the path. First the data of the element is freed, then I enter a loop where the condition is that the loop is exited once the path is NULL. Inside the loop, the element is first deleted, the memory is freed, and the next thing on the path is popped. The size of the level is decremented, but then I enter an if statement that checks if that particular level is empty. I do that by setting a third pointer to the sentinel and iterating down until I reach the level that q is on (the pointer being one step behind). Then I move the pointer around and delete the level along with freeing it's data, and then I reset q to be what the new pointer is so the loop can continue correctly. There's one special case, if sentinel->down is deleted i.e. everything is deleted, then the superlist must be reinitialized. If the level isn't empty, then q is simply set to the level above by popping. 

Repository_get:
	The logic is the same as delete and insert, if the key is equal, then the loop returns, if it is greater then it points down, and across, etc., once the loop exits i.e. p points to NULL (below the bottom level) then the key wasn't found and it returns 0.

Repository_print:
	First I make the same two pointers point to the sentinel. I also create two variables to keep track of what level it's looking at. I use two so I can start from the highest level and go down. So first I just run through the head elements, incrementing the level variable each time. I then print the size of the bottom level end along with printing my counter. Next, I run through the head elements one more time printing the size of each level. As described in the project, I check whether the parameter is a 1, 2, or neither. If it's 1, then the pointer is already at the bottom level, so I just run through it printing each element. If it's 2, then I set both pointers to the beginning of the top level. It iterates through the list, and when it gets to the end, the head pointer goes down, and then the traversal pointer is set to the head pointer, and this repeats until the pointers are NULL. Otherwise, it just returns.

Note: I made two stacks by creating two separate methods with the same code, but different names, corresponding to the differnt stacks.